// Generated by PInvoke Wizard (v 1.0) from The Paul Yao Company http://www.paulyao.com 

using System;
using System.Drawing;

namespace GapiDrawNet
{
	[Flags]
	public enum OpenDisplayOptions
	{
		// Display flags
		GDDISPLAY_SHOWLOGO             = 0x0001, // Show GapiDraw logo and version on startup
		GDDISPLAY_FULLSCREEN           = 0x0010, // Request a full screen lock of the display
		GDDISPLAY_WINDOW               = 0x0020, // Open the display in windowed mode - default
		GDDISPLAY_BACKBUFFERSYSMEM     = 0x0040, // Backbuffer is stored in system memory - default windowed
		GDDISPLAY_BACKBUFFERVIDMEM     = 0x0080, // Backbuffer is stored in video memory - default full screen

//		// Open display options
//		GDOPENDISPLAY_NORMAL		   = 0x0000, // 
//		GDOPENDISPLAY_SHOWVERSION      = 0x0001, // Show DLL version on startup
//		GDOPENDISPLAY_FULLSCREEN       = 0x0002, // (Stationary PCs) Request a full screen lock of the display
//		GDOPENDISPLAY_SIZEX2           = 0x0010, // (Stationary PCs) Open display in 2x resolution
//		GDOPENDISPLAY_SIZEX25          = 0x0020, // (Stationary PCs) Open display in 2.5x resolution
//		GDOPENDISPLAY_SIZEX32          = 0x0040, // (Stationary PCs) Open display in 3.2x resolution
//		GDOPENDISPLAY_SCALEX2          = 0x0100, // (Stationary PCs) Scale display to 2x resolution
//		GDOPENDISPLAY_SCALEX3          = 0x0200, // (Stationary PCs) Scale display to 3x resolution
//		GDOPENDISPLAY_SCALEX4          = 0x0400, // (Stationary PCs) Scale display to 4x resolution
//		GDOPENDISPLAY_POCKETPC         = 0x1000, // (Stationary PCs) Open display as PocketPC (DEFAULT) (240x320)
//		GDOPENDISPLAY_SMARTPHONE       = 0x2000, // (Stationary PCs) Open display as Smartphone         (176x220)
	}

	[Flags]
	public enum CreateSurfaceOptions : uint
	{
		// Surface flags
		GDSURFACE_CLEAR                = 0x0001, // The surface is cleared after creation
		GDSURFACE_ALPHA                = 0x0002, // Use only alpha information when loading a transparent image
		GDSURFACE_NOCOORDCHECK         = 0x0004, // Coordinate verifications are disabled
		GDSURFACE_SYSTEMMEMORY         = 0x0100, // The surface is stored in system memory - default windowed
		GDSURFACE_VIDEOMEMORY          = 0x0200, // The surface is stored in video memory - default full screen
		GDSURFACE_LOCALVIDMEM          = 0x0400, // The surface is stored in local video memory - default
		GDSURFACE_NONLOCALVIDMEM       = 0x0800, // The surface is stored in non local video memory
		GDSURFACE_LOCKED               = 0x1000, // The surface is locked
		GDSURFACE_VIDEOLOCKED          = 0x2000, // The surface is video locked
		GDSURFACE_PRIMARY              = 0x4000, // Direct writes to the display is enabled
		GDSURFACE_GDI                  = 0x8000, // The surface is stored as a GDI bitmap
		//		// Surface creation flags
		//		GDCREATESURFACE_NORMAL		   = 0, 
		//		GDCREATESURFACE_CLEAR          = 0x0001, // Clears the surface after creation
		//	}
	}

	[Flags]
	public enum RgbaSurfaceOptions : uint
	{
		// RGBA Surface flags
		GDRGBASURFACE_CLEAR            = 0x0001, // The surface is cleared after creation
		GDRGBASURFACE_12BIT            = 0x0010, // Use 12-bit RGBA format (444A)
		GDRGBASURFACE_32BIT            = 0x0020, // Use 32-bit RGBA format (555A or 565A) - default
		GDRGBASURFACE_SYSTEMMEMORY     = 0x0100, // Create the surface in system memory (default)
	}

	public enum DisplayMode : uint
	{
		GDDISPMODE_NORMAL              = 0x0001, // Use normal display mode - default
		GDDISPMODE_ROTATE90CCW         = 0x0002, // Rotate display 90 degrees counter clockwise
		GDDISPMODE_ROTATE90CW          = 0x0004, // Rotate display 90 degrees clockwise
		GDDISPMODE_ROTATE180           = 0x0008, // Rotate display 180 degrees

//		// Display mode attributes
//		GDDISPMODE_NORMAL              = 0x0001, // Use normal display mode (default)
//		GDDISPMODE_LANDSCAPE1          = 0x0002, // Rotate display 90 degrees counter clockwise
//		GDDISPMODE_LANDSCAPE2          = 0x0003, // Rotate display 90 degrees clockwise
	}

	public enum PixelFormats : uint
	{
		GDPIXELFORMAT_444			   = 0x0001, // 16-bit RGB  (xxxxrrrr ggggbbbb)
		GDPIXELFORMAT_555              = 0x0002, // 16-bit RGB  (xrrrrrgg gggbbbbb)
		GDPIXELFORMAT_565              = 0x0004, // 16-bit RGB  (rrrrrggg gggbbbbb) 
		GDPIXELFORMAT_444A             = 0x0010, // 16-bit RGBA (rrrrgggg bbbbaaaa)
		GDPIXELFORMAT_555A             = 0x0020, // 32-bit RGBA (xrrrrrgg gggbbbbb xxxxxxxx aaaaaaaa)
		GDPIXELFORMAT_565A             = 0x0040, // 32-bit RGBA (rrrrrggg gggbbbbb xxxxxxxx aaaaaaaa)
	}

//	[Flags]
//	public enum DisplayCaps
//	{
//		// Display capabilities
//		GDDISPCAPS_DIRECT              = 0x0001, // Display surface is capable of direct writes to the screen area
//	}
//

//
//	[Flags]
//	public enum GapiSurfaceOptions
//	{
//		// Surface options
//		GDSURFOPTION_DONOTVERIFY       = 0x0001, // Disable coordinate verifications on a surface
//	}
//
//	// Blt options
	[Flags]
	public enum BltOptions : uint
	{
		// Blt options
		GDBLT_KEYSRC                   = 0x0001, // Uses the color key in the source surface
		GDBLT_COLORFILL                = 0x0002, // Uses the specified color instead of source image color (source image can be NULL)
		GDBLT_OPACITY                  = 0x0004, // Specifies opacity of the source image (0 transparent - 255 opaque)
		GDBLT_MIRRORLEFTRIGHT          = 0x0010, // Mirrors the source image left-right
		GDBLT_MIRRORUPDOWN             = 0x0020, // Mirrors the source image upside down
		GDBLT_ROTATIONANGLE            = 0x0100, // Clockwise rotation angle in 1/100 degrees (3000 = 30.00 degrees)
		GDBLT_ROTATIONSCALE            = 0x0200, // Rotation scale in percentage (100 = 100% of original scale)
		GDBLT_ROTATIONCENTER           = 0x0400, // Rotation pivot point center (can be negative)
//		GDBLT_KEYSRC                   = 0x0001, // Uses the color key in the source surface
//		GDBLT_COLORFILL                = 0x0002, // Uses the specified color instead of source image color (source image can be NULL)
//		GDBLT_OPACITY                  = 0x0004, // Specifies opacity of the source image (0 transparent - 255 opaque)
//		GDBLT_MIRRORLEFTRIGHT          = 0x0010, // Mirrors the source image left-right
//		GDBLT_MIRRORUPDOWN             = 0x0020, // Mirrors the source image upside down
//		GDBLT_ROTATIONANGLE            = 0x0040, // Clockwise rotation angle in 1/100 degrees (3000 = 30.00 degrees)
//		GDBLT_ROTATIONSCALE            = 0x0080, // Rotation scale in percentage (100 = 100% of original scale)
	}

	[Flags]
	public enum BltFastOptions : uint
	{	// BltFast options
		GDBLTFAST_KEYSRC               = 0x0001, // Masks out the colors specified by KEYSRC before blitting
		GDBLTFAST_COLORFILL            = 0x0002, // Uses the specified color instead of source image color (source image can be NULL)
		GDBLTFAST_OPACITY              = 0x0004, // Specifies opacity of the source image (0 transparent - 255 opaque)
		GDBLTFAST_FXOPACITY            = 0x0008, // FX Opacity: Uses the value in GDBLTFASTFX.dwFXopacity to control amount of effect (0-255)
		GDBLTFASTFX_MULTIPLY           = 0x0010, // FX Color multiply: Uses the color in GDBLTFASTFX.dwFXcolor1 to multiply source
		GDBLTFASTFX_SCREEN             = 0x0020, // FX Color screen: Uses the color in GDBLTFASTFX.dwFXcolor1 to screen source
		GDBLTFASTFX_OVERLAY            = 0x0040, // FX Color overlay: Uses the color in GDBLTFASTFX.dwFXcolor1 to overlay source
		GDBLTFASTFX_TINT               = 0x0100, // FX Color tint: Uses the angle in GDBLTFASTFX.dwFXparam1 to adjust source hue ((-180)-(180) degrees)
		GDBLTFASTFX_COLORIZE           = 0x0200, // FX Colorize: Uses the color in GDBLTFASTFX.dwFXcolor1 to colorize source
	}

	[Flags]
	public enum AlphaBltOptions : uint
	{	// AlphaBlt options
		GDALPHABLT_OPACITY             = 0x0001, // Specifies opacity of the source image (0 transparent - 255 opaque)
		GDALPHABLT_MIRRORLEFTRIGHT     = 0x0010, // Mirrors the source left-right
		GDALPHABLT_MIRRORUPDOWN        = 0x0020, // Mirrors the source upside down

//		GDABLT_COLORFILL               = 0x0001, // Uses the specified color instead of source image color (source image can be NULL)
//		GDABLT_OPACITY                 = 0x0002, // Specifies opacity of the source image (0 transparent - 255 opaque)
//		GDABLT_MIRRORLEFTRIGHT         = 0x0010, // Mirrors the source left-right
//		GDABLT_MIRRORUPDOWN            = 0x0020, // Mirrors the source upside down
	}

	[Flags]
	public enum AlphaBltFastOptions : uint
	{
		// AlphaBltFast options
		GDALPHABLTFAST_OPACITY         = 0x0001, // Specifies opacity of the source image (0 transparent - 255 opaque)
	}

	// Line options (DrawLine, DrawRect)
	[Flags]
	public enum DrawLineOptions : uint
	{
		GDDRAWLINE_OPACITY             = 0x0001, // Uses opacity to blend the lines with the background 
        GDDRAWLINE_ANTIALIAS           = 0x0002, // Uses a fast fixed point WU algorithm to smooth the line
    }

	[Flags]
	public enum SetPixelsOptions : uint
	{
		// SetPixel options
		GDPIXEL_OPACITY                = 0x0001, // Uses opacity to blend the pixel with the background 
		GDPIXEL_DISABLED               = 0x0100, // Do not draw this pixel
		GDSETPIXELS_FIXEDPOINT         = 0x1000, // Use 16:16 fixed point coordinates
	}

	[Flags]
	public enum FillRectOptions : uint
	{
		// FillRect options
		GDFILLRECT_OPACITY             = 0x0001, // Specifies opacity of the GDRect (0 transparent - 255 opaque)
	}

//	[Flags]
//	public enum Other
//	{
//
//
//		// Pixel formats
//		GDPIXELFORMAT_555              = 0x0001, // The pixel format of the surface is 555 
//		GDPIXELFORMAT_565              = 0x0002, // The pixel format of the surface is 565 
//
//
//		// SetPixel options
//		GDPIXEL_OPACITY                = 0x0001, // Uses opacity to blend the pixel with the background 
//		GDPIXEL_DISABLED               = 0x0100, // Do not draw this pixel
//				
//	}

	[Flags]
	public enum DrawTextOptions : uint
	{
		// Text attributes
		GDDRAWTEXT_LEFT                = 0x0001, // Draw left-aligned text (dwX = text left, dwY = text top) - default mode
		GDDRAWTEXT_CENTER              = 0x0002, // Draw centered text (dwX = text center)
		GDDRAWTEXT_RIGHT               = 0x0004, // Draw right-aligned text (dwX = text right)
//		GDDRAWTEXT_CALCWIDTH           = 0x0010, // Do not draw any text, only calculate the width necessary to draw it
//		GDDRAWTEXT_BORDER              = 0x0100, // (System font only) Draw text with a black border.
	}

	[Flags]
	public enum CreateFontOptions : uint
	{
		// Bitmap font creation
		GDCREATEFONT_TRACKING          = 0x0001, // Font tracking (space between characters) in pixels
		GDCREATEFONT_SIMPLEBITMAP      = 0x0002, // Use simple bitmap format with no adjustable character kerning
	}

	[Flags]
	public enum SaveSurfaceOptions : uint
	{
		// Save Surface flags
		GDSAVESURFACE_BMP              = 0x0001, // Save surface as 24-bit BMP image - default
		GDSAVESURFACE_PNG              = 0x0002, // Save surface as true color PNG image
	}

	[Flags]
	public enum VideohardwareFlags : uint
	{
		// Video hardware status
		GDVIDEOHW_VIDMEM               = 0x0001, // Video memory is available and enabled
		GDVIDEOHW_VSYNC                = 0x0010, // Video HW can sync flip to vertical blank
	}

//	[Flags]
//	public enum CreateCursorOptions
//	{
//		// Cursor creation
//		GDCREATECURSOR_KEYSRC          = 0x0001, // Use a key sourced cursor bitmap (DEFAULT).
//		GDCREATECURSOR_ALPHABLEND      = 0x0002, // Use an alpha blended cursor bitmap. 
//	}
//
//	//	Return codes ______________________________________________________________

	public enum GapiResults : uint
	{
		// OK
		GD_OK                             = 0,
		// OUTOFMEMORY: Memory allocation failed.
		GDERR_OUTOFMEMORY                 = 1,
		// INVALIDPARAMS: One or more arguments are either NULL or contain invalid values.
		GDERR_INVALIDPARAMS               = 2,
		// NOTLOCKED: The surface is not locked, and cannot be unlocked.
		GDERR_NOTLOCKED                   = ((UInt32)0xC8660010),
		// NODC: Cannot unlock surface using DC since it was not locked using GetDC.
		GDERR_NODC                        = ((UInt32)0xC8660020),
		// DCLOCKED: The surface is locked using a DC, and cannot be unlocked using Unlock().
		GDERR_DCLOCKED                    = ((UInt32)0xC8660030),
		// CANTCREATEDC: Attempt to create DC failed.
		GDERR_CANTCREATEDC                = ((UInt32)0xC8660040),
		// BITMAPWRITEERROR: The bitmap file could not be written.
		GDERR_BITMAPWRITEERROR            = ((UInt32)0xC8660050),
		// BITMAPNOTFOUND: The specified bitmap could not be found.
		GDERR_BITMAPNOTFOUND              = ((UInt32)0xC8660060),
		// INVALIDBITMAP: The bitmap file could not be parsed.
		GDERR_INVALIDBITMAP               = ((UInt32)0xC8660070),
		// NOTINITIALIZED: All surface objects must be created before use (OpenDisplay/CreateSurface).
		GDERR_NOTINITIALIZED              = ((UInt32)0xC8660080),
		// INVALIDSURFACETYPE: Cannot call CreateSurface on objects of type CGapiDisplay.
		GDERR_INVALIDSURFACETYPE          = ((UInt32)0xC8660090),
		// INCOMPATIBLEPRIMARY: Primary surface does not exist or is aligned different to the current surface.
		GDERR_INCOMPATIBLEPRIMARY         = ((UInt32)0xC86600a0),
		// PRIMARYSURFACEALREADYEXISTS: Cannot call OpenDisplay if a primary surface already has been assigned.
		GDERR_PRIMARYSURFACEALREADYEXISTS = ((UInt32)0xC86600b0),
		// LOCKEDSURFACES: One or more surfaces are locked, preventing operation.
		GDERR_LOCKEDSURFACES              = ((UInt32)0xC86600c0),
		// LOCKEDKEYS: Keys have already been locked in a previous operation.
		GDERR_LOCKEDKEYS                  = ((UInt32)0xC86600d0),
		// INVALIDRECT: One or more rectangles are invalid.
		GDERR_INVALIDRECT                 = ((UInt32)0xC86600e0),
		// FRAMETIMEOVERFLOW: Unable to maintain target frame rate
		GDERR_FRAMETIMEOVERFLOW           = ((UInt32)0x486600f0),
		// GDERR_INVALIDMODE: Invalid display mode
		GDERR_INVALIDMODE                 = ((UInt32)0xC8660100),
		// GDERR_UNSUPPORTEDMODE: Unsupported display resolution or incompatible device
		GDERR_UNSUPPORTEDMODE             = ((UInt32)0xC8660110),
		// GDERR_NOGAPI: The GAPI file "gx.dll" is not available on the target device.
		GDERR_NOGAPI                      = ((UInt32)0xC8660120),
		// GDERR_NOVIDEOHW: The device does not have any video acceleration
		GDERR_NOVIDEOHW                   = ((UInt32)0xC8660130),
		// GDERR_NOVIDEOSURFACE: The surface is not stored in video memory
		GDERR_NOVIDEOSURFACE              = ((UInt32)0xC8660140),
		// GDERR_SURFACELOST: The contents of a video surface was destroyed
		GDERR_SURFACELOST                 = ((UInt32)0xC8660150),
		// GDERR_SURFACEBUSY: A surface is already busy with a hardware blit operation
		GDERR_SURFACEBUSY                 = ((UInt32)0xC8660160)
	
//		GD_OK                             = 0,
//		// OUTOFMEMORY: Memory allocation failed.
//		GDERR_OUTOFMEMORY                 = 1,
//		// INVALIDPARAMS: One or more arguments are either NULL or contain invalid values.
//		GDERR_INVALIDPARAMS               = 2,
//		// NOTLOCKED: The surface is not locked, and cannot be unlocked.
//		GDERR_NOTLOCKED                   = ((UInt32)0xC8660010),
//		// NODC: Cannot unlock surface using DC since it was not locked using GetDC.
//		GDERR_NODC                        = ((UInt32)0xC8660020),
//		// DCLOCKED: The surface is locked using a DC, and cannot be unlocked using Unlock().
//		GDERR_DCLOCKED                    = ((UInt32)0xC8660030),
//		// CANTCREATEDC: Attempt to create DC failed.
//		GDERR_CANTCREATEDC                = ((UInt32)0xC8660040),
//		// BITMAPWRITEERROR: The bitmap file could not be written.
//		GDERR_BITMAPWRITEERROR            = ((UInt32)0xC8660050),
//		// BITMAPNOTFOUND: The specified bitmap could not be found.
//		GDERR_BITMAPNOTFOUND              = ((UInt32)0xC8660060),
//		// INVALIDBITMAP: The bitmap file could not be parsed.
//		GDERR_INVALIDBITMAP               = ((UInt32)0xC8660070),
//		// NOTINITIALIZED: All surface objects must be created before use (OpenDisplay/CreateSurface).
//		GDERR_NOTINITIALIZED              = ((UInt32)0xC8660080),
//		// INVALIDSURFACETYPE: Cannot call CreateSurface on objects of type CGapiDisplay.
//		GDERR_INVALIDSURFACETYPE          = ((UInt32)0xC8660090),
//		// INCOMPATIBLEPRIMARY: Primary surface does not exist or is aligned different to the current surface.
//		GDERR_INCOMPATIBLEPRIMARY         = ((UInt32)0xC86600a0),
//		// PRIMARYSURFACEALREADYEXISTS: Cannot call OpenDisplay if a primary surface already has been assigned.
//		GDERR_PRIMARYSURFACEALREADYEXISTS = ((UInt32)0xC86600b0),
//		// LOCKEDSURFACES: One or more surfaces are locked, preventing operation.
//		GDERR_LOCKEDSURFACES              = ((UInt32)0xC86600c0),
//		// LOCKEDKEYS: Keys have already been locked in a previous operation.
//		GDERR_LOCKEDKEYS                  = ((UInt32)0xC86600d0),
//		// INVALIDRECT: One or more GDRects are invalid.
//		GDERR_INVALIDRECT                 = ((UInt32)0xC86600e0),
//		// BACKBUFFERLOST: The back surface of the display was lost during a flip, please request a new using GetBackBuffer
//		GDERR_BACKBUFFERLOST              = ((UInt32)0xC86600f0),
//		// FRAMETIMEOVERFLOW: Unable to maintain target frame rate
//		GDERR_FRAMETIMEOVERFLOW           = ((UInt32)0x48660100),
//		// GDERR_INVALIDMODE: Invalid display mode
//		GDERR_INVALIDMODE                 = ((UInt32)0x48660110),
//		// GDERR_UNSUPPORTEDMODE: Unsupported display resolution or incompatible (8-bit) device
//		GDERR_UNSUPPORTEDMODE             = ((UInt32)0xC8660120),
//		// GDERR_NOGAPI: The file "gx.dll" is not available on the target device.
//		GDERR_NOGAPI                      = ((UInt32)0xC8660130)
	}

//

//
//	public struct GDSURFACEDESC
//	{
//		public int dwWidth;
//		public int dwHeight;
//		public int lPitch;
//		public short pSurface;
//		public int dwPixelFormat;
//	};
//





//	public struct GDTEXTFX
//	{
//		public int dwBorderColor;
//	};

	

	public struct GDKEYLIST
	{
		public int vkUp;
		public int vkDown;
		public int vkLeft;
		public int vkRight;
		public int vkStart;
		public int vkA;
		public int vkB;
		public int vkC;
	};

	public struct GDBUFFERDESC
	{
		public int dwWidth;
		public int dwHeight;
		public int xPitch;
		public int yPitch;
		public IntPtr pBuffer;  /// check!
		public int dwPixelFormat;
	};

	public struct GDBLTFX
	{
		public int dwFillColor;
		public int dwOpacity;
		public int dwRotationAngle;
		public int dwRotationScale;
		public System.Drawing.Point rotationCenter;
	};
	//	public struct GDBLTFX
	//	{
	//		public int dwFillColor;
	//		public int dwOpacity;
	//		public int dwRotationAngle;
	//		public int dwRotationScale;
	//	};

    /// <summary>
    /// This struct is used by CGapiSurface::BltFast().
    /// </summary>
	public struct GDBLTFASTFX
	{
        /// <summary>
        /// Uses the specified color instead of source image color.
        /// </summary>
		public int dwFillColor;
        /// <summary>
        /// Specifies opacity of the source image (0 transparent - 128 (50% quick alpha) - 255 opaque)
        /// </summary>
        public int dwOpacity;
        /// <summary>
        /// Parameter1 to send to the blit effects. See documentation on 
        /// CGapiSurface::BltFast for details.
        /// </summary>
        public int dwFXparam1;
        /// <summary>
        /// Color1 to send to the blit effects. See documentation on CGapiSurface::BltFast for details.
        /// </summary>
        public int dwFXcolor1;
        /// <summary>
        /// The amount of blending to use for the effect. See documentation on CGapiSurface::BltFast for details.
        /// </summary>
        public int dwFXopacity;
	};

	public struct GDALPHABLTFX
	{
		public int dwOpacity;
	};
	//	public struct GDALPHABLTFX
	//	{
	//		public int dwFillColor;
	//		public int dwOpacity;
	//	};

	public struct GDALPHABLTFASTFX
	{
		public int dwOpacity;
	};
	//	public struct GDALPHABLTFASTFX
	//	{
	//		public int dwFillColor;
	//		public int dwOpacity;
	//	};

	public struct GDPIXELFX
	{
		public int dwOpacity;
	};

	public struct GDLINEFX
	{
		public int dwOpacity;
	};

	public struct GDFILLRECTFX
	{
		public int dwOpacity;
	};

	public struct GDFONTFX
	{
		public int lTracking;
	};

	public struct GDPIXEL
	{
		public int x;
		public int y;
		public int dwColor;
		public int dwFlags;
		public int  pixelfx;
//		public int dwX;
//		public int dwY;
//		public int dwColor;
//		public int dwFlags;
//		public GDPIXELFX pixelfx;
	};

	unsafe public struct GDPIXELNODE
	{
		public GDPIXEL pixel;
		public GDPIXELNODE* pNext;
	};

	public struct GDSURFACE
	{
		public int dwFlags;
		public int dwWidth;
		public int dwHeight;
		public int xPitch;
		public int yPitch;
		public int xyOffset;
		public int dwSize;
		public int dwOrientation;
		public int ckSrcBlt;
		public GDRect viewport;
		public IntPtr pVideoLink;
		public IntPtr pBuffer;
	};
	//	public struct GDSURFACE
	//	{
	//		public int dwWidth;
	//		public int dwHeight;
	//		public int xPitch;
	//		public int yPitch;
	//		public int xyOffset;
	//		public int dwSize;
	//		public short pSurface;
	//		public int dwOrientation;
	//		public int dwFlags;
	//		public int ckSrcBlt;
	//	};

	public struct GDLOCKEDSURFACE
	{
		public IntPtr hLockedDC;
		public IntPtr hLockedHandle;
		public IntPtr pBuffer;
	};

	public struct GDFONTKERNING
	{
		public char tcChar1;
		public char tcChar2;
		public int lOffset;
		public IntPtr pNext;
	};

	public struct GDBITMAPFONT
	{
		public int dwTop;
		public int dwWidth;
		public int dwHeight;
		public int lTracking;
		public int pOffset;
		public int pWidth;
		public int pKerningLeft;
		public int pKerningRight;
		public GDFONTKERNING pKerningList;
		public int dwFlags;
	};

	public struct GDTIMER
	{
		public float nTargetFrameTime;
		public float nActualFrameTime;
		public float nActualThreadTime;
		public int dwTargetFrameRate;
		public int dwFrameTimes;
		public int dwThreadTimes;
		public int dwLastFrameTime;
		public int dwFrameTimeIndex;
		public int dwFrameIndex;
		public int dwTickCount;
		public int dwLowResStartTick;
		public Int64 nPerformanceStartTick;
		public Int64 nPerformanceFrequency;
		public int dwFlags;
	};

	public struct GDCURSOR
	{
		public System.Drawing.Point position;
		public System.Drawing.Point hotspot;
		public int dwFrameCount;
		public int dwFrameStep;
		public int dwFrameIndex;
		public int dwUpdateIndex;
		public int dwFlags;
	};
}